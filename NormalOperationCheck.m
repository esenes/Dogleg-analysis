% NormalOperationCheck:  
% This script is intended to use the Norm files generated by readMATandsort.m by
% the data of the TD26CC structure, which is under test now in the dogleg.
%
% The aim of the script is to check the proper working of the machine
% using the backup pulses rather than the BD pulses.
% 
% REV. 1. by Eugenio Senes and Theodoros Argyropoulos
%
% Last modified 02.06.2016 by Eugenio Senes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
close all; clearvars; clc;
if strcmp(computer,'MACI64') %just hit add to path when prompted
    addpath(genpath('/Users/esenes/scripts/Dogleg-analysis-master'))
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User input %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
datapath_read = '/Users/esenes/swap_out/exp';
datapath_write = '/Users/esenes/swap_out/exp';
fileName = 'Norm_full_Loaded43MW_7';
%%%%%%%%%%%%%%%%%%%%%%%%%% End of user input %%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%% Parameters %%%%%%%%%%%%%%%%%%%%%%%
% BPM CHARGE THRESHOLDS
bpm1_thr = -100;
bpm2_thr = -90;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% pulse begin/end for probability
pbeg = 400;
pend = 474;

%% Load the BD files
tic
disp('Loading the data file ....')
load([datapath_read filesep fileName '.mat']);
disp('Done.')
toc
disp(' ')

%% Get field names and list of L0 events in the file
event_name = {};
j = 1;
foo = fieldnames(data_struct);
for i = 1:length(foo)
    if strcmp(foo{i}(end-1:end),'L0')
        event_name{j} = foo{i};
        j = j+1;
    end    
end    
clear j, foo;
%% Parse the interesting event one by one and build the arrays of data for selection
% allocation
    %beam charge
    bpm1_ch = zeros(1,length(event_name));
    bpm2_ch = zeros(1,length(event_name));
    %timestamps list    
    ts_array = zeros(1,length(event_name));
% filling    
for i = 1:length(event_name) 
    bpm1_ch(i) = data_struct.(event_name{i}).BPM1.sum_cal;
    bpm2_ch(i) = data_struct.(event_name{i}).BPM2.sum_cal;
    % build a timestamps array
    [~, ts_array(i)] = getFileTimeStamp(data_struct.(event_name{i}).name);
    
    %probability of BD is int(P^3 dt)
    p3 = data_struct.(event_name{i}).INC.data_cal (pbeg:pend);
    p3 = p3.^3;
    dt = 4e-9;
    prob(i) = sum(p3*dt);
end

%% filling for plotting
    %peak and average power
    pk_pwr = zeros(1,length(event_name));
    avg_pwr = zeros(1,length(event_name));
    %tuning
    tuning_slope = zeros(1,length(event_name));
    tuning_delta = zeros(1,length(event_name));
    failSlope = 0;
    failDelta = 0;
    %pulse length
    top_len = zeros(1,length(event_name));
    mid_len = zeros(1,length(event_name));
    bot_len = zeros(1,length(event_name));
    fail_m1=0;
for i = 1:length(event_name) 
    pk_pwr(i) = data_struct.(event_name{i}).INC.max;
    avg_pwr(i) = data_struct.(event_name{i}).INC.avg.INC_avg;
    ft_end = 462; %change it if pulse length changes from nominal
    if data_struct.(event_name{i}).tuning.fail_m2 ~= true
        tuning_slope(i) = data_struct.(event_name{i}).tuning.slope;
        tuning_delta(i) = getDeltaPower(tuning_slope(i),...
            data_struct.(event_name{i}).tuning.x1,ft_end);
    else 
        tuning_slope(i) = NaN;
        tuning_delta(i) = NaN;
        failSlope = failSlope+1;
        failDelta = failDelta+1;
    end
    if data_struct.(event_name{i}).tuning.fail_m1 ~= true
        top_len(i) = 4e-9*(data_struct.(event_name{i}).tuning.top.x2 - data_struct.(event_name{i}).tuning.top.x1);
        mid_len(i) = 4e-9*(data_struct.(event_name{i}).tuning.mid.x2 - data_struct.(event_name{i}).tuning.mid.x1);
        bot_len(i) = 4e-9*(data_struct.(event_name{i}).tuning.bot.x2 - data_struct.(event_name{i}).tuning.bot.x1);
    else
        top_len(i) = NaN;
        mid_len(i) = NaN;
        bot_len(i) = NaN;
        fail_m1 = fail_m1+1;
    end
end
%% Parameters check plots 
%Get screen parameters in order to resize the plots
% screensizes = get(groot,'screensize'); %only MATLAB r2014b+
% screenWidth = screensizes(3);
% screenHeight = screensizes(4);
% winW = screenWidth/2;
% winH = screenHeight/2;
winW = 1420;
winH = 760;
%Calculate the timescale for the x of the charge plot
xscale = zeros(1,length(ts_array));
ts_array_vec = datevec(ts_array); 
for k=1:length(ts_array)
    xscale(k) = etime(ts_array_vec(k,:),ts_array_vec(1,:));
end
xscale = xscale/60; %in minutes
%Charge distribution plot
f1 = figure('position',[0 0 winW winH]);
figure(f1)
subplot(2,1,1)
plot(xscale, bpm1_ch,'.','MarkerSize',12);
line(xlim, [bpm1_thr bpm1_thr], 'Color', 'r','LineWidth',1) %horizontal line
title('BPM1 charge distribution')
xlabel('Minutes')
ylabel('Integrated charge')
legend('Acquisition','threshold')
subplot(2,1,2)
plot(xscale,bpm2_ch,'.','MarkerSize',12)
line(xlim, [bpm2_thr bpm2_thr], 'Color', 'r','LineWidth',1) %horizontal line
title('BPM2 charge distribution')
xlabel('Minutes')
ylabel('Integrated charge')
legend('Interlocks','threshold')
% print(f1,[datapath_write filesep fileName '_charge_distribution'],'-djpeg')
% savefig([datapath_write filesep fileName '_charge_distribution'])


%% Start the filtering 
% filling bool arrays
    [hasBeam,~,~] = beamCheck(bpm1_ch, bpm1_thr, bpm2_ch, bpm2_thr,'bpm1');
% filling event arrays    
    %w/ and w/o beam
    Beam = event_name(hasBeam);
    noBeam = event_name(~hasBeam);

    
%%
% %% Report message and crosscheck of lengths
% disp('Analysis done! ')
% %open the log file and append
% logID = fopen([datapath_write filesep savename '.log'], 'a' ); 
% %gather data and build the message
% %%INTO THE METRIC
% l1 = length(BD_candidates);
% l2 = length(spikes_inMetric);
% l3 = length(spike_cluster);
% l4 = length(missed_beam_in);
% l5 = length(missed_beam_cluster);
% msg2 = ['BD candidates found: ' num2str(length(inMetric)) ' of which ' num2str(length(intoMetr)) ' are into the metric' '\n' ...
%     'Into the metric:' '\n' ...
% ' - ' num2str(l1) ' are good candidates' '\n' ...
% ' - ' num2str(l2) ' are spikes' '\n' ...
% ' - ' num2str(l3) ' are secondary triggered by spikes' '\n' ...
% ' - ' num2str(l4) ' are missed beam pulses' '\n' ...
% ' - ' num2str(l5) ' are secondary triggered by beam lost' '\n' ...
% '-------' '\n' ...
% '  ' num2str(l1+l2+l3+l4+l5) ' events in metric' '\n \n' ...
% 'Of the ' num2str(l1) ' good candidates:' '\n' ...
% ' - ' num2str(length(BD_candidates_beam)) ' have the beam' '\n' ...
% ' - ' num2str(length(BD_candidates_nobeam)) ' do not have the beam' '\n \n' ...
% 'Of the ' num2str(length(BD_candidates_beam)) ' BDs with the beam: \n' ...
% ' - '  num2str(length(clusters_wb)) ' are BDs with the beam present, but part of a cluster provoked by a BD happpened without beam' '\n'...
% ' - '  num2str(length(clusters_wob)) ' are BDs without the beam present, but part of a cluster provoked by a BD happpened without beam' '\n'...
% 'So the final number of breakdowns is ' num2str(length(BDs)) '\n' ...
% '\n \n' ...
% ];
% %%OUT OF THE METRIC
% l1 = length(interlocks_out);
% l2 = length(spikes_outMetric);
% l3 = length(spike_cluster_out);
% msg3 = ['Out of the metric:' '\n' ...
% ' - ' num2str(l1) ' are BDs ' '\n' ...
% ' - ' num2str(l2) ' are spikes' '\n' ...
% ' - ' num2str(l3) ' are secondary triggered by spikes' '\n' ...
% '-------' '\n' ...
% '  ' num2str(l1+l2+l3) ' events out of the metric' '\n \n' ...
% ];
% % print to screen (1) and to log file
% fprintf(1,msg2);
% fprintf(1,msg3);
% fprintf(logID,msg2);
% fprintf(logID,msg3);
% fclose(logID);

%% Distributions plots
% peak power distribution
f3 = figure('position',[0 0 winW winH]);
figure(f3)
xbins = linspace(0,round(max(pk_pwr),-6),(1e-6*round(max(pk_pwr),-6)+1));
h1 = hist(pk_pwr(hasBeam),xbins);
h2 = hist(pk_pwr(~hasBeam),xbins);
bar([h1;h2]','stack')
legend({'With Beam','Without Beam'},'Position',[.15 .8 .085 .085])
xlabel('Power (MW)')
ylabel('Counts')
title('Overall distribution of peak incident power for backup events')
% print(f3,[datapath_write filesep fileName '_peak_power_distribution'],'-djpeg')
% savefig([datapath_write filesep fileName '_peak_power_distribution'])
% average power distribution
f4 = figure('position',[0 0 winW winH]);
figure(f4)
xbins = linspace(0,round(max(pk_pwr),-6),(1e-6*round(max(pk_pwr),-6)+1)); %1MW per bin
h1 = hist(avg_pwr(hasBeam),xbins);
h2 = hist(avg_pwr(~hasBeam),xbins);
bar([h1;h2]','stack')
legend({'With Beam','Without Beam'},'Position',[.15 .8 .085 .085])
xlabel('Power (MW)')
ylabel('Counts')
title('Overall distribution of average incident power for backup events')
% print(f4,[datapath_write filesep fileName '_average_power_distribution'],'-djpeg')
% savefig([datapath_write filesep fileName '_average_power_distribution'])


% % Probability plot
% f5 = figure('position',[0 0 winW winH]);
% figure(f5)
% %xbins = 0:4:(round(max(bot_len)*1e9)+2);
% histogram(prob(inMetric));
% xlabel('$$ \int P^3 d \tau $$','interpreter','latex')
% ylabel('Counts')
% title('BD probability')
% print(f5,[datapath_write filesep fileName '_BD_probability_metric'],'-djpeg')
% savefig([datapath_write filesep fileName '_BD_probability_metric'])


% tuning delta power distribution
f8 = figure('position',[0 0 winW winH]);
figure(f8)
subplot(2,1,1)
tmp_tuning = tuning_delta;
xbins = linspace(-20e6,20e6,41); %1M per bin
histogram(tmp_tuning(hasBeam),xbins)
title('Backup pulses tuning distribution: pulses with beam')
xlabel('Power delta (W)')
ylabel('Counts')
subplot(2,1,2)
tmp_tuning = tuning_delta;
xbins = linspace(-20e6,20e6,41); %1M per bin
histogram(tmp_tuning(~hasBeam),xbins)
title('Backuo pulses tuning distribution: pulses without beam ')
xlabel('Power delta (W)')
ylabel('Counts')
print(f8,[datapath_write filesep fileName '_tuning_delta_power_distribution'],'-djpeg')
savefig([datapath_write filesep fileName '_tuning_delta_power_distribution'])
% % peak normalized power distribution vs BDR
% f9 = figure('position',[0 0 winW winH]);
% figure(f9)
% xbins = linspace(0,round(max(pk_pwr),-6),(1e-6*round(max(pk_pwr),-6)+1));
% h3 = hist(pk_pwr(inMetric & ~isSpike & ~(sec_spike) & ~beam_lost & ~(sec_beam_lost) & hasBeam & ~clusters),xbins);
% h3 = h3/sum(h3);
% bar(h3,'stack')
% hold on
% BDR = h3(43) * ( ((xbins+1e6)/(43e6)).^15 );
% plot(BDR,'r')
% axis([0 50 0 max(h3)+.01])
% axis autox
% hold off
% legend({'BDs','BDR distribution'},'Position',[.15 .8 .085 .085])
% xlabel('Power (MW)')
% ylabel('Normalized frequency')
% title('Overall distribution of peak incident power')
% print(f9,[datapath_write filesep fileName '_peak_power_distribution_vs_BDR'],'-djpeg')
% savefig([datapath_write filesep fileName '_peak_power_distribution_vs_BDR'])
% pulse length
f10 = figure('position',[0 0 winW winH]);
figure(f10)
subplot(2,1,1)
top_tmp = top_len(hasBeam);
mid_tmp = mid_len(hasBeam);
bot_tmp = bot_len(hasBeam);
xbins = 0:4:(round(max(bot_len)*1e9)+2);
histogram(top_tmp*1e9,xbins);
title('Pulse width at various heights for backup pulses with beam')
hold on
histogram(mid_tmp*1e9,xbins);
hold on
histogram(bot_tmp*1e9,xbins);
l = legend({'85%','65%','40%'},'Position',[.15 .8 .085 .085]);
xlabel('Pulse width (ns)')
ylabel('Counts')
hold off
subplot(2,1,2)
top_tmp = top_len(~hasBeam);
mid_tmp = mid_len(~hasBeam);
bot_tmp = bot_len(~hasBeam);
xbins = 0:4:(round(max(bot_len)*1e9)+2);
histogram(top_tmp*1e9,xbins);
title('Pulse width at various heights for backup pulses without beam')
hold on
histogram(mid_tmp*1e9,xbins);
hold on
histogram(bot_tmp*1e9,xbins);
l = legend({'85%','65%','40%'},'Position',[.15 .8 .085 .085]);
xlabel('Pulse width (ns)')
ylabel('Counts')
hold off
% print(f10,[datapath_write filesep fileName '_pulse_width_distribution'],'-djpeg')
% savefig([datapath_write filesep fileName '_pulse_width_distribution'])
